
    function completeBidding(uint itemType, uint itemId) public payable nonReentrant {
        require(itemType == 2 || itemType == 3, "Invalid item type");

        if (itemType == 2) {
            address marketTokenOwner = idToMarketToken[itemId]._owner;
            uint highestBid = idToBidToken[itemId].highestBid;

            payable(marketTokenOwner).transfer(highestBid);

            idToBidToken[itemId].completed = true;
            idToMarketToken[itemId]._owner = idToBidToken[itemId].highestBidder;

            address nftContract = idToMarketToken[itemId].nftContract;
            uint tokenId = idToMarketToken[itemId].tokenId;
            address highestBidder = idToBidToken[itemId].highestBidder;

            IERC721(nftContract).safeTransferFrom(address(this), highestBidder, tokenId);
        } else if (itemType == 3) {
            address marketTokenOwner = idToMarketToken[itemId]._owner;
            uint highestBid = idToAuctionToken[itemId].highestBid;
            AuctionToken storage at = idToAuctionToken[itemId];

            require(at.auctionEndTime <= block.timestamp, "Auction is not over yet");
            require(at.completed == false, "Auction is already completed");

            payable(marketTokenOwner).transfer(highestBid);

            idToAuctionToken[itemId].closed = true;
            idToAuctionToken[itemId].completed = true;
            idToMarketToken[itemId]._owner = at.highestBidder;

            address nftContract = idToMarketToken[itemId].nftContract;
            uint tokenId = idToMarketToken[itemId].tokenId;
            address highestBidder = at.highestBidder;

            IERC721(nftContract).safeTransferFrom(address(this), highestBidder, tokenId);
        }
    }

